"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var task_1 = require("./task");
var chalk_1 = tslib_1.__importDefault(require("chalk"));
// @ts-ignore
var get_1 = tslib_1.__importDefault(require("lodash/get"));
// @ts-ignore
var flatten_1 = tslib_1.__importDefault(require("lodash/flatten"));
var execa = require("execa");
var nodeVersionChecker_1 = require("./nodeVersionChecker");
var execTask_1 = require("../utils/execTask");
var simpleGit = require('simple-git/promise')(process.cwd());
var tasks = {
    lint: {
        sass: ['newer:sasslint'],
        core: ['newer:exec:tslintRoot'],
        gui: ['newer:exec:tslintPackages'],
    },
    typecheck: {
        core: ['newer:exec:typecheckRoot'],
        gui: ['newer:exec:typecheckPackages'],
    },
    test: {
        lint: {
            ts: ['no-only-tests'],
            go: ['no-focus-convey-tests'],
        },
    },
};
var precommitRunner = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var status, sassFiles, tsFiles, testFiles, goTestFiles, grafanaUiFiles, affectedNodeVersionFiles, grafanaUIFilesChangedOnly, coreFilesChangedOnly, taskPaths, gruntTasks, task, stream;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, simpleGit.status()];
            case 1:
                status = _a.sent();
                sassFiles = status.files.filter(function (file) { return file.path.match(/^[a-zA-Z0-9\_\-\/]+(\.scss)$/g) || file.path.indexOf('.sass-lint.yml') > -1; });
                tsFiles = status.files.filter(function (file) { return file.path.match(/^[a-zA-Z0-9\_\-\/]+(\.(ts|tsx))$/g); });
                testFiles = status.files.filter(function (file) { return file.path.match(/^[a-zA-Z0-9\_\-\/]+(\.test.(ts|tsx))$/g); });
                goTestFiles = status.files.filter(function (file) { return file.path.match(/^[a-zA-Z0-9\_\-\/]+(\_test.go)$/g); });
                grafanaUiFiles = tsFiles.filter(function (file) { return file.path.indexOf('grafana-ui') > -1; });
                affectedNodeVersionFiles = status.files
                    .filter(function (file) { return nodeVersionChecker_1.nodeVersionFiles.indexOf(file.path) !== -1; })
                    .map(function (f) { return f.path; });
                grafanaUIFilesChangedOnly = tsFiles.length > 0 && tsFiles.length - grafanaUiFiles.length === 0;
                coreFilesChangedOnly = tsFiles.length > 0 && grafanaUiFiles.length === 0;
                taskPaths = [];
                if (!(affectedNodeVersionFiles.length > 0)) return [3 /*break*/, 3];
                return [4 /*yield*/, execTask_1.execTask(nodeVersionChecker_1.nodeVersionCheckerTask)({})];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3:
                if (sassFiles.length > 0) {
                    taskPaths.push('lint.sass');
                }
                if (testFiles.length) {
                    taskPaths.push('test.lint.ts');
                }
                if (goTestFiles.length) {
                    taskPaths.push('test.lint.go');
                }
                if (tsFiles.length > 0) {
                    if (grafanaUIFilesChangedOnly) {
                        taskPaths.push('lint.gui', 'typecheck.core', 'typecheck.gui');
                    }
                    else if (coreFilesChangedOnly) {
                        taskPaths.push('lint.core', 'typecheck.core');
                    }
                    else {
                        taskPaths.push('lint.core', 'lint.gui', 'typecheck.core', 'typecheck.gui');
                    }
                }
                gruntTasks = flatten_1.default(taskPaths.map(function (path) { return get_1.default(tasks, path); }));
                if (gruntTasks.length > 0) {
                    console.log(chalk_1.default.yellow("Precommit checks: " + taskPaths.join(', ')));
                    task = execa('grunt', gruntTasks);
                    stream = task.stdout;
                    if (stream) {
                        stream.pipe(process.stdout);
                    }
                    return [2 /*return*/, task];
                }
                console.log(chalk_1.default.yellow('Skipping precommit checks, not front-end changes detected'));
                return [2 /*return*/];
        }
    });
}); };
exports.precommitTask = new task_1.Task('Precommit task', precommitRunner);
//# sourceMappingURL=precommit.js.map